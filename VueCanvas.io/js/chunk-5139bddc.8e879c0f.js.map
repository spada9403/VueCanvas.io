{"version":3,"sources":["webpack:///./src/views/CanvasView.vue","webpack:///src/views/CanvasView.vue","webpack:///./src/views/CanvasView.vue?fd3a","webpack:///./src/views/CanvasView.vue?e24d","webpack:///./src/views/CanvasView.vue?be29"],"names":["render","_vm","this","_c","_self","ref","staticClass","on","downloadCanvas","_v","clearCanvas","staticRenderFns","data","canvas","ctx","paintColor","lineWidth","painting","canvasWidth","canvasHeight","mounted","methods","startPaintInPc","paintLineInPc","startPaintInMobile","x","y","paintLineInMobile","e","getTouchPoint","stopPainting","link","canvasToBase64ToBinary","console","content","destroyed","component"],"mappings":"yHAAA,IAAIA,EAAS,WAAkB,IAAIC,EAAIC,KAAKC,EAAGF,EAAIG,MAAMD,GAAG,OAAOA,EAAG,MAAM,CAACA,EAAG,SAAS,CAACE,IAAI,SAASC,YAAY,WAAWH,EAAG,SAAS,CAACI,GAAG,CAAC,MAAQN,EAAIO,iBAAiB,CAACP,EAAIQ,GAAG,yBAAyBN,EAAG,SAAS,CAACI,GAAG,CAAC,MAAQN,EAAIS,cAAc,CAACT,EAAIQ,GAAG,qBAE5PE,EAAkB,GCQP,GACfC,OACA,OAEAC,YACAC,SAEAC,mBACAC,cAEAC,YAEAC,gBACAC,mBAGAC,UAEA,8BAMA,mCACA,qCAIA,8DACA,6DACA,0DACA,6DAEA,mEACA,iEACA,2DACA,8DAGA,sCACA,qCACA,mCAEAC,SAEAC,iBACA,kBAEAC,iBAEA,kBACA,YACA,eAQA,qBAGA,oBARA,qBACA,uBAWAC,sBAEA,QAAAC,IAAAC,GAAA,sBACA,qBACA,qBACA,kBAEAC,qBAGAC,mBAGA,QAAAH,IAAAC,GAAA,sBACA,gBAGA,qBAEA,oBAGAG,iBAEA,4BAGA,OACAJ,UACAC,YAIAI,eACA,kBAEApB,cAIA,4DAGAF,iBAGA,gCAGA,8BAIAuB,wBAEAA,SACAA,WAEAC,yBAEA,gCAIA,qBAIA,2BAGA,kBAEA,uCACAC,yCACAA,2CAEA,SAKA,2BACA,QACAC,QAEAA,UAaAC,YAGA,iEACA,gEACA,6DACA,gEAGA,sEACA,oEACA,8DACA,mEC7LoV,I,wBCQhVC,EAAY,eACd,EACApC,EACAW,GACA,EACA,KACA,KACA,MAIa,aAAAyB,E,kECnBf","file":"js/chunk-5139bddc.8e879c0f.js","sourcesContent":["var render = function render(){var _vm=this,_c=_vm._self._c;return _c('div',[_c('canvas',{ref:\"canvas\",staticClass:\"canvas\"}),_c('button',{on:{\"click\":_vm.downloadCanvas}},[_vm._v(\"Download Canvas IMG\")]),_c('button',{on:{\"click\":_vm.clearCanvas}},[_vm._v(\"Clear Canvas\")])])\n}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\r\n  <div>\r\n    <!-- canvas 속성에 ref=\"canvas\"을 추가하여 Vue 인스턴스.$refs 오브젝트에 'canvas'라는 필드명으로 태그추가 -->\r\n    <canvas class=\"canvas\" ref=\"canvas\"></canvas>\r\n    <button @click=\"downloadCanvas\">Download Canvas IMG</button>\r\n    <button @click=\"clearCanvas\">Clear Canvas</button>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {\r\n      // Canvas태그 오브젝트 및 'Context'를 담을 변수 선언\r\n      canvas: null,\r\n      ctx: null,\r\n      // Canvas 옵션 설정\r\n      paintColor: \"black\", // rgba 또는 #000000 사용 가능\r\n      lineWidth: 2.5,\r\n      // 사용자가 그리기 시작했는지의 여부\r\n      painting: false,\r\n      // Canvas의 크기 설정\r\n      canvasWidth: 500,\r\n      canvasHeight: 500,\r\n    };\r\n  },\r\n  mounted() {\r\n    // template 에서 Vue 인스턴스.$refs 에 추가한 canvas 태그를 꺼내 변수에 저장.\r\n    this.canvas = this.$refs.canvas;\r\n\r\n    // canvas태그의 넓이, 높이 설정. css(style)이 아닌, 태그 속성(Attribute)으로 명시하거나, (sample => <canvas width='500' height='500' ></canvas>)\r\n    // 아래와 같이 직접 canvas 태그에 접근해 속성 할당. 설정하지 않으면\r\n    // 기본값인 width 300px, height 150px으로 적용됨.\r\n    //*** css의 width, height 'px값'과 맞춰줘야 그린대로 정확히 그려집니다. (태그의 크기와 속성으로 설정한 크기가 다르면 그만큼 마우스 또는 터치 위치의 괴리가 발생)\r\n    this.canvas.width = this.canvasWidth;\r\n    this.canvas.height = this.canvasHeight;\r\n\r\n    // 서명을 할 때 일어날 마우스 및 터치 이벤트를 canvas 태그에 걸기.\r\n    // FOR PC\r\n    this.canvas.addEventListener(\"mousedown\", this.startPaintInPc);\r\n    this.canvas.addEventListener(\"mousemove\", this.paintLineInPc);\r\n    this.canvas.addEventListener(\"mouseup\", this.stopPainting);\r\n    this.canvas.addEventListener(\"mouseleave\", this.stopPainting);\r\n    // FOR MOBILE\r\n    this.canvas.addEventListener(\"touchstart\", this.startPaintInMobile);\r\n    this.canvas.addEventListener(\"touchmove\", this.paintLineInMobile);\r\n    this.canvas.addEventListener(\"touchend\", this.stopPainting);\r\n    this.canvas.addEventListener(\"touchcancel\", this.stopPainting);\r\n\r\n    // canvas 태그의 context 설정(서명 사인을 할 때 선의 색상, 굵기등을 조절).\r\n    this.ctx = this.canvas.getContext(\"2d\"); // canvas 태그의 'context'를 변수에 저장\r\n    this.ctx.strokeStyle = this.paintColor; // 선의 색상\r\n    this.ctx.lineWidth = this.lineWidth; // 선의 굵기\r\n  },\r\n  methods: {\r\n    // FOR PC CANVAS EVENT FUNCTIONS\r\n    startPaintInPc() {\r\n      this.painting = true;\r\n    },\r\n    paintLineInPc(e) {\r\n      // canvas 태그에서 마우스를 움직일 때 마우스 좌표 가져오기.\r\n      const x = e.offsetX;\r\n      const y = e.offsetY;\r\n      if (!this.painting) {\r\n        // 아직 그리지 않을때 즉, 'mousedown' 이벤트가 일어나지 않았을때 (마우스가 canvas 위에 올라와 있을 때)\r\n        // 현재 마우스 좌표를 시작점으로 설정함.\r\n        this.ctx.beginPath(); // 마우스 이동 경로 즉, 선의 이동경로의 시작점을 초기화 합니다.\r\n        this.ctx.moveTo(x, y); // 초기화된 선의 이동경로의 시작점으로 마우스 좌표를 옮깁니다.\r\n      } else {\r\n        // 'mousedown' 이벤트가 일어나서 즉, 사용자가 그리기 시작했을 때\r\n        // 설정된 선의 이동경로의 시작점 부터 현재 마우스의 좌표까지 경로를 만듭니다.\r\n        this.ctx.lineTo(x, y);\r\n\r\n        // 만들어진 경로를 따라 strokeStyle에 설정 된 색상으로 선을 긋습니다.\r\n        this.ctx.stroke();\r\n      }\r\n    },\r\n    // FOR MOBILE CANVAS EVENT FUNCTIONS\r\n    startPaintInMobile(e) {\r\n      // canvas를 제일 처음 터치하였을 때 즉, 그리기 시작할 때의 좌표를 구합니다.\r\n      const { x, y } = this.getTouchPoint(e);\r\n      this.ctx.beginPath(); // 터치중 움직임 즉, 그려질 선의 이동경로의 시작점 초기화\r\n      this.ctx.moveTo(x, y); // 초기화된 선의 이동경로 시작점으로 마우스 좌표 옮김.\r\n      this.painting = true;\r\n    },\r\n    paintLineInMobile(e) {\r\n      // 터치를 할 상태로 움직일 경우, 터치 기본 이벤트로 화면이 움직이는데\r\n      // 해당 기본 이벤트는 사인을 할 때 방해가 되므로 기본 이벤트를 막음.\r\n      e.preventDefault();\r\n\r\n      // canvas 태그에서 터치 되었을때 터치좌표 구하기.\r\n      const { x, y } = this.getTouchPoint(e);\r\n      if (this.painting) {\r\n        // 'touchmove' 이벤트가 일어났을 때(touch 중 움직임) 즉, 사용자가 그리기 시작하였을 때\r\n        // 설정된 선의 이동경로의 시작점부터 현재 터치중인 좌표까지 경로를 만듭니다.\r\n        this.ctx.lineTo(x, y);\r\n        // 만들어진 경로를 따라 strokeStyle에 설정 된 색상으로 선을 긋습니다.\r\n        this.ctx.stroke();\r\n      }\r\n    },\r\n    getTouchPoint(e) {\r\n      // 인식한 터치 이벤트중 제일 처음 터치된 이벤트를 가져옵니다.(2손가락으로 터치시 제일 처음 터치한 손가락을 인식)\r\n      const touches = e.changedTouches[0];\r\n\r\n      // 가져온 터치 이벤트의 좌표를 리턴합니다.\r\n      return {\r\n        x: touches.pageX,\r\n        y: touches.pageY,\r\n      };\r\n    },\r\n    // PUBLIC CANVAS FUNCTIONS\r\n    stopPainting() {\r\n      this.painting = false;\r\n    },\r\n    clearCanvas() {\r\n      // clearRect 함수는 4개의 파라미터를 받습니다. (x,y,width,height)\r\n      // x,y,는 0을 주고(왼쪽 상단 모서리 부터),width와 height 값을 canvas의 width, height 속성에 준 값과 동일한 값을\r\n      // 넣어주게 되면, 왼쪽 상단 모서리 부터 오른쪽 하단 모서리까지 즉, canvas 전체 화면을 비우게 됩니다.\r\n      this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\r\n    },\r\n    // CANVAS DOWNLOAD & POST METHODS\r\n    downloadCanvas() {\r\n      // canvas 태그에 그려진 그림을 base64 로 인코딩된 이미지 파일로 변환\r\n      // *** base64로 인코딩된 이미지 파일은 'text'로 되어있으며, img tag등의 src에 넣으면 이미지로 표시됩니다.\r\n      const imgData = this.canvas.toDataURL();\r\n\r\n      // 'a' tag 생성\r\n      const link = document.createElement(\"a\");\r\n\r\n      // 'a' tag에 'download' 속성 사용 시 'a' tag 에 연결된 href가 파일이라면 해당 링크 click시 파일을 다운로드를 받음.\r\n      // 파일을 다운로드 할 때 다운받을 파일의 이름 설정.\r\n      link.download = \"canvas.png\";\r\n      // 'a' tag에 연결할 href 설정. data url(base64로 인코딩된 이미지) 을 연결하면, 해당 링크로 이동 시 이미지가 표시됨.\r\n      link.href = imgData;\r\n      link.click();\r\n    },\r\n    canvasToBase64ToBinary() {\r\n      // 아래 코딩은 base64로 인코딩된 이미지만 첨부 할 수 있습니다. bse64 이미지가 아닌 일반 파일 같은 경우엔, catch문과 같이 합니다.\r\n      const imgFile = this.canvas.toDataURL(); // canvas 태그에 그려진 그림을 base64 인코딩된 이미지(data url)로 변환\r\n\r\n      // base64 인코딩된 이미지는 앞부분의 data Type 부분과 뒷부분의 base64 text 부분이 ','로 나뉘어져 있음.\r\n      // example : data:image/png;base64,iVBORw0KGgoAAAANSUhEUgA....\r\n      const splitBase64Image = imgFile.value.split(\",\");\r\n\r\n      // base64 인코딩된 이미지의 dataType 부분에서 data: 부분을 날림.\r\n      // data:image/png;base64 To image/png;base64\r\n      const dataType = splitBase64Image[0].replace(\"data:\", \"\");\r\n\r\n      // dataType에서 이미지의 encode Type 을 가져옴.\r\n      const encodeType = dataType.split(\";\")[1];\r\n      // dataType에서 이미지의 extension(확장자)를 가져옴.\r\n      const imageType = dataType.split(\";\")[0].replace(\"image/\", \"\");\r\n      console.log(\"image encoding type => \", encodeType);\r\n      console.log(\"image image extension => \", imageType);\r\n      // data url 의 즉, base64인코딩된 이미지의 base64 텍스트만 저장할 변수 선언.\r\n      let content = \"\";\r\n\r\n      // 한번에 표시할 수 있는 text의 숫자가 정해져있어서, 이미지 파일용량이 클 수록\r\n      // ','로 쪼개져있다. 그래서 앞의 데이터 부분을 제외하고 splitBase64Image[1]하고 바로 접근하여 다운로드 하거나, formData로 쏘면\r\n      // 이미지 파일이 깨져서 저장 or 송신 되므로, 데이터 부분을 제외한 index 번호 1부터 각 데이터 사이에 ','를 포함하여 'content' 변수에 다시 담아준다.\r\n      for (let index = 1; index < splitBase64Image.length; index++) {\r\n        if (content != \"\") {\r\n          content += \",\";\r\n        }\r\n        content += splitBase64Image[index];\r\n      }\r\n      // JSON 데이터로 보내기\r\n      // const ret = {\r\n      //   base64Image: content,\r\n      // };\r\n      // axios({data : JSON.stringify(ret)})\r\n\r\n      // form-data로 보내기.\r\n      // const form = new FormData();\r\n      // form.append(fieldName, Buffer.from(Buffer.from(content, encodeType), \"binary\"), fileName);\r\n    },\r\n  },\r\n  destroyed() {\r\n    // 컴포넌트가 언로드 될때 canvas 태그에 걸려있던 이벤트들 제거\r\n    // FOR PC\r\n    this.canvas.removeEventListener(\"mousedown\", this.startPaintInPc);\r\n    this.canvas.removeEventListener(\"mousemove\", this.paintLineInPc);\r\n    this.canvas.removeEventListener(\"mouseup\", this.stopPainting);\r\n    this.canvas.removeEventListener(\"mouseleave\", this.stopPainting);\r\n\r\n    // FOR MOBILE\r\n    this.canvas.removeEventListener(\"touchstart\", this.startPaintInMobile);\r\n    this.canvas.removeEventListener(\"touchmove\", this.paintLineInMobile);\r\n    this.canvas.removeEventListener(\"touchend\", this.stopPainting);\r\n    this.canvas.removeEventListener(\"touchcancel\", this.stopPainting);\r\n  },\r\n};\r\n</script>\r\n\r\n<style>\r\n.canvas {\r\n  border: 1px solid black;\r\n  width: 500px;\r\n  height: 500px;\r\n}\r\n</style>\r\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./CanvasView.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./CanvasView.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./CanvasView.vue?vue&type=template&id=67e83388&\"\nimport script from \"./CanvasView.vue?vue&type=script&lang=js&\"\nexport * from \"./CanvasView.vue?vue&type=script&lang=js&\"\nimport style0 from \"./CanvasView.vue?vue&type=style&index=0&id=67e83388&prod&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--7-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--7-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--7-oneOf-1-2!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./CanvasView.vue?vue&type=style&index=0&id=67e83388&prod&lang=css&\""],"sourceRoot":""}